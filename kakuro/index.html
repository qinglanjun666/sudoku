<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kakuro (Cross Sums) - Logic for Sudoku</title>
  <meta name="description" content="Play Kakuro (Cross Sums) online. Fill the grid with numbers 1-9 so that each run adds up to the clue." />
  <link rel="stylesheet" href="/src/index.css" />
  <style>
    :root {
      --cell-size: 50px;
      --board-border: 2px solid #333;
      --cell-border: 1px solid #555;
      --bg-blank: #222;
      --bg-input: #fff;
      --bg-clue: #ddd; /* Light grey for clue cells */
      --text-clue: #000;
      --text-input: #000;
      --selection-color: #bbdefb; /* Light Blue */
      --highlight-color: #e3f2fd; /* Very Light Blue */
      --error-color: #ffcdd2; /* Light Red */
      --error-text: #d32f2f;
    }

    .main-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    .game-container {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    #kakuro-board {
      display: grid;
      /* Grid template columns will be set via JS based on board size */
      border: var(--board-border);
      background-color: var(--bg-blank);
      user-select: none;
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      border: var(--cell-border);
      box-sizing: border-box;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Courier New', Courier, monospace;
      font-weight: bold;
      cursor: default;
      position: relative;
    }

    /* Cell Types */
    .cell.blank {
      background-color: var(--bg-blank);
    }

    .cell.input {
      background-color: var(--bg-input);
      color: var(--text-input);
      font-size: 24px;
      cursor: pointer;
    }

    .cell.clue {
      background-color: var(--bg-clue);
      color: var(--text-clue);
      /* Diagonal line from top-left to bottom-right */
      background-image: linear-gradient(to bottom right, transparent 48%, #000 48%, #000 52%, transparent 52%);
    }

    .clue-val {
      position: absolute;
      font-size: 11px;
      line-height: 1;
    }
    .clue-right {
      top: 4px;
      right: 4px;
    }
    .clue-down {
      bottom: 4px;
      left: 4px;
    }

    /* States */
    .cell.input.selected {
      background-color: var(--selection-color);
    }
    .cell.input.highlight {
      background-color: var(--highlight-color);
    }
    .cell.clue.highlight {
      background-color: #ccc; /* Slightly darker grey for highlighted clues */
    }
    .cell.input.error {
      background-color: var(--error-color);
      color: var(--error-text);
    }

    /* Controls */
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 400px;
    }
    
    .numpad {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
      margin-top: 10px;
    }
    
    .num-btn {
      width: 40px;
      height: 40px;
      font-size: 18px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .num-btn:hover {
      background: #eee;
    }
    .num-btn.action-btn {
      background: #f0f0f0;
      font-size: 14px;
    }

    /* Modal */
    #victoryModal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 8px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }

    @media (max-width: 600px) {
      :root {
        --cell-size: 40px;
      }
    }
  </style>
</head>
<body>
  <div id="site-header"></div>
  
  <main class="main-wrap">
    <div class="container">
      <h1 class="title">Kakuro (Cross Sums)</h1>
      <p class="subtitle">Fill the white cells with numbers 1-9. The sum of each block must match the clue. No duplicate numbers in a block.</p>
      
      <div class="game-container">
        <div id="kakuro-board"></div>
        
        <div class="controls">
          <button id="checkBtn" class="btn btn-primary">Check Solution</button>
          <button id="resetBtn" class="btn">Reset</button>
        </div>

        <div class="numpad">
          <button class="num-btn" data-val="1">1</button>
          <button class="num-btn" data-val="2">2</button>
          <button class="num-btn" data-val="3">3</button>
          <button class="num-btn" data-val="4">4</button>
          <button class="num-btn" data-val="5">5</button>
          <button class="num-btn" data-val="6">6</button>
          <button class="num-btn" data-val="7">7</button>
          <button class="num-btn" data-val="8">8</button>
          <button class="num-btn" data-val="9">9</button>
          <button class="num-btn action-btn" data-val="clear">X</button>
        </div>
      </div>
    </div>
  </main>

  <div id="victoryModal">
    <div class="modal-content">
      <h2>Puzzle Solved!</h2>
      <p>Great job! You've mastered this logic puzzle.</p>
      <button class="btn btn-primary" onclick="document.getElementById('victoryModal').style.display='none'">Close</button>
    </div>
  </div>

  <div id="site-footer"></div>

  <script>
    // Load Header/Footer
    Promise.all([
      fetch('../partials/header.html').then(r => r.text()),
      fetch('../partials/footer.html').then(r => r.text())
    ]).then(([h, f]) => {
      document.getElementById('site-header').innerHTML = h
      document.getElementById('site-footer').innerHTML = f
    })

    // Game Logic
    // Types: 0=Blank, 1=Clue, 2=Input
    const TYPE_BLANK = 0;
    const TYPE_CLUE = 1;
    const TYPE_INPUT = 2;

    // Level Data (5x5 Grid)
    // Clue format: [down, right] (0 if none)
    // Input format: null (initially)
    // 3x3 Magic Square-ish Logic derived earlier:
    // Rows: 7(1,2,4), 9(3,5,1), 6(2,1,3)
    // Cols: 6(1,3,2), 8(2,5,1), 8(4,1,3)
    
    const initialBoard = [
      // Row 0
      [
        { type: TYPE_BLANK },
        { type: TYPE_CLUE, down: 6, right: 0 },
        { type: TYPE_CLUE, down: 8, right: 0 },
        { type: TYPE_CLUE, down: 8, right: 0 },
        { type: TYPE_BLANK }
      ],
      // Row 1
      [
        { type: TYPE_CLUE, down: 0, right: 7 },
        { type: TYPE_INPUT, val: null, answer: 1 },
        { type: TYPE_INPUT, val: null, answer: 2 },
        { type: TYPE_INPUT, val: null, answer: 4 },
        { type: TYPE_BLANK }
      ],
      // Row 2
      [
        { type: TYPE_CLUE, down: 0, right: 9 },
        { type: TYPE_INPUT, val: null, answer: 3 },
        { type: TYPE_INPUT, val: null, answer: 5 },
        { type: TYPE_INPUT, val: null, answer: 1 },
        { type: TYPE_BLANK }
      ],
      // Row 3
      [
        { type: TYPE_CLUE, down: 0, right: 6 },
        { type: TYPE_INPUT, val: null, answer: 2 },
        { type: TYPE_INPUT, val: null, answer: 1 },
        { type: TYPE_INPUT, val: null, answer: 3 },
        { type: TYPE_BLANK }
      ],
      // Row 4
      [
        { type: TYPE_BLANK },
        { type: TYPE_BLANK },
        { type: TYPE_BLANK },
        { type: TYPE_BLANK },
        { type: TYPE_BLANK }
      ]
    ];

    let board = JSON.parse(JSON.stringify(initialBoard));
    let selected = null; // {r, c}

    const boardEl = document.getElementById('kakuro-board');
    
    function initGame() {
      renderBoard();
      setupInputs();
    }

    function renderBoard() {
      boardEl.style.gridTemplateColumns = `repeat(${board[0].length}, var(--cell-size))`;
      boardEl.innerHTML = '';

      board.forEach((row, r) => {
        row.forEach((cell, c) => {
          const div = document.createElement('div');
          div.classList.add('cell');
          div.dataset.r = r;
          div.dataset.c = c;

          if (cell.type === TYPE_BLANK) {
            div.classList.add('blank');
          } else if (cell.type === TYPE_CLUE) {
            div.classList.add('clue');
            if (cell.right > 0) {
              const span = document.createElement('span');
              span.className = 'clue-val clue-right';
              span.textContent = cell.right;
              div.appendChild(span);
            }
            if (cell.down > 0) {
              const span = document.createElement('span');
              span.className = 'clue-val clue-down';
              span.textContent = cell.down;
              div.appendChild(span);
            }
          } else if (cell.type === TYPE_INPUT) {
            div.classList.add('input');
            if (cell.val) div.textContent = cell.val;
            
            div.addEventListener('click', () => selectCell(r, c));
          }
          boardEl.appendChild(div);
        });
      });
      updateHighlights();
    }

    function selectCell(r, c) {
      selected = {r, c};
      updateHighlights();
    }

    function updateHighlights() {
      // Clear previous
      document.querySelectorAll('.cell').forEach(el => {
        el.classList.remove('selected', 'highlight', 'error');
      });

      // Find dupes and mark errors
      const errors = findDuplicates();
      errors.forEach(({r, c}) => {
         const el = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
         if(el) el.classList.add('error');
      });

      if (!selected) return;

      const selEl = document.querySelector(`.cell[data-r="${selected.r}"][data-c="${selected.c}"]`);
      if (selEl) selEl.classList.add('selected');

      // Highlight row and col runs
      const { rowCells, colCells, rowClue, colClue } = getRuns(selected.r, selected.c);
      
      [...rowCells, ...colCells].forEach(({r, c}) => {
        const el = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
        if (el) el.classList.add('highlight');
      });

      if (rowClue) {
        const el = document.querySelector(`.cell[data-r="${rowClue.r}"][data-c="${rowClue.c}"]`);
        if (el) el.classList.add('highlight');
      }
      if (colClue) {
        const el = document.querySelector(`.cell[data-r="${colClue.r}"][data-c="${colClue.c}"]`);
        if (el) el.classList.add('highlight');
      }
    }

    function getRuns(r, c) {
      // Horizontal Run
      let rowCells = [];
      let rowClue = null;
      // Go left
      for (let i = c; i >= 0; i--) {
        if (board[r][i].type === TYPE_INPUT) {
          if (i !== c) rowCells.push({r, c: i});
        } else if (board[r][i].type === TYPE_CLUE) {
          rowClue = {r, c: i};
          break;
        } else {
          break;
        }
      }
      // Go right
      for (let i = c + 1; i < board[0].length; i++) {
        if (board[r][i].type === TYPE_INPUT) {
          rowCells.push({r, c: i});
        } else {
          break;
        }
      }

      // Vertical Run
      let colCells = [];
      let colClue = null;
      // Go up
      for (let i = r; i >= 0; i--) {
        if (board[i][c].type === TYPE_INPUT) {
          if (i !== r) colCells.push({r: i, c});
        } else if (board[i][c].type === TYPE_CLUE) {
          colClue = {r: i, c};
          break;
        } else {
          break;
        }
      }
      // Go down
      for (let i = r + 1; i < board.length; i++) {
        if (board[i][c].type === TYPE_INPUT) {
          colCells.push({r: i, c});
        } else {
          break;
        }
      }

      return { rowCells, colCells, rowClue, colClue };
    }

    function findDuplicates() {
      let errors = [];
      // Simple check: iterate all runs. If a run has duplicate numbers, mark them.
      // We can iterate all cells, get their runs, check dupes.
      // Optimization: iterate all Input cells.
      
      // To avoid complexity, just re-scan the whole board by rows and cols
      // Rows
      for (let r=0; r<board.length; r++) {
        let currentRun = [];
        for (let c=0; c<board[0].length; c++) {
           if (board[r][c].type === TYPE_INPUT) {
             currentRun.push({r, c, val: board[r][c].val});
           } else {
             checkRun(currentRun, errors);
             currentRun = [];
           }
        }
        checkRun(currentRun, errors);
      }
      // Cols
      for (let c=0; c<board[0].length; c++) {
        let currentRun = [];
        for (let r=0; r<board.length; r++) {
           if (board[r][c].type === TYPE_INPUT) {
             currentRun.push({r, c, val: board[r][c].val});
           } else {
             checkRun(currentRun, errors);
             currentRun = [];
           }
        }
        checkRun(currentRun, errors);
      }
      return errors;
    }

    function checkRun(run, errors) {
      if (run.length < 2) return;
      const counts = {};
      run.forEach(cell => {
        if (cell.val) {
          counts[cell.val] = (counts[cell.val] || 0) + 1;
        }
      });
      run.forEach(cell => {
        if (cell.val && counts[cell.val] > 1) {
          errors.push({r: cell.r, c: cell.c});
        }
      });
    }

    function setVal(val) {
      if (!selected) return;
      const {r, c} = selected;
      if (val === 'clear') {
        board[r][c].val = null;
      } else {
        board[r][c].val = parseInt(val);
      }
      
      // Update DOM
      const el = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      el.textContent = board[r][c].val || '';
      
      updateHighlights();
    }

    function setupInputs() {
      // Numpad
      document.querySelectorAll('.num-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault(); // Prevent focus loss issues on some devices
          const val = btn.dataset.val;
          setVal(val);
        });
      });

      // Keyboard
      document.addEventListener('keydown', (e) => {
        if (!selected) return;
        if (e.key >= '1' && e.key <= '9') {
          setVal(e.key);
        } else if (e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') {
          setVal('clear');
        } else if (e.key === 'ArrowUp') {
           if (selected.r > 0) selectCell(selected.r - 1, selected.c);
        } else if (e.key === 'ArrowDown') {
           if (selected.r < board.length - 1) selectCell(selected.r + 1, selected.c);
        } else if (e.key === 'ArrowLeft') {
           if (selected.c > 0) selectCell(selected.r, selected.c - 1);
        } else if (e.key === 'ArrowRight') {
           if (selected.c < board[0].length - 1) selectCell(selected.r, selected.c + 1);
        }
      });

      // Reset
      document.getElementById('resetBtn').addEventListener('click', () => {
        if(confirm('Reset puzzle?')) {
          board = JSON.parse(JSON.stringify(initialBoard));
          renderBoard();
          selected = null;
        }
      });

      // Check Solution
      document.getElementById('checkBtn').addEventListener('click', checkSolution);
    }

    function checkSolution() {
      // 1. Check if all filled
      let filled = true;
      for(let r=0; r<board.length; r++){
        for(let c=0; c<board[0].length; c++){
          if(board[r][c].type === TYPE_INPUT && !board[r][c].val) {
            filled = false;
          }
        }
      }
      if (!filled) {
        alert('Please fill all white cells first.');
        return;
      }

      // 2. Check duplicates
      if (findDuplicates().length > 0) {
        alert('There are duplicate numbers in some rows or columns.');
        return;
      }

      // 3. Check Sums
      // Iterate all Clues and check their runs
      let correct = true;
      
      // Horizontal Sums (Clue Right)
      for(let r=0; r<board.length; r++){
        for(let c=0; c<board[0].length; c++){
          if(board[r][c].type === TYPE_CLUE && board[r][c].right > 0) {
             let sum = 0;
             for(let k=c+1; k<board[0].length; k++) {
               if(board[r][k].type === TYPE_INPUT) sum += (board[r][k].val || 0);
               else break;
             }
             if (sum !== board[r][c].right) correct = false;
          }
        }
      }
      
      // Vertical Sums (Clue Down)
      for(let r=0; r<board.length; r++){
        for(let c=0; c<board[0].length; c++){
          if(board[r][c].type === TYPE_CLUE && board[r][c].down > 0) {
             let sum = 0;
             for(let k=r+1; k<board.length; k++) {
               if(board[k][c].type === TYPE_INPUT) sum += (board[k][c].val || 0);
               else break;
             }
             if (sum !== board[r][c].down) correct = false;
          }
        }
      }

      if (correct) {
        document.getElementById('victoryModal').style.display = 'flex';
      } else {
        alert('Some sums are incorrect. Keep trying!');
      }
    }

    initGame();

  </script>
</body>
</html>
