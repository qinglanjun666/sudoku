<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Futoshiki - Logic for Sudoku</title>
    <meta name="description" content="Play Futoshiki online. A logic puzzle where you fill the grid with numbers satisfying inequality constraints.">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    
    <!-- Global Styles -->
    <link rel="stylesheet" href="../src/index.css">

    <style>
        /* Scoped Styles for Futoshiki Page */
        :root {
            --game-grid-size: 320px;
            --cell-size: calc(var(--game-grid-size) / 4);
            --symbol-color: #6b7280;
        }

        body {
            background-color: #fff;
            color: var(--color-text);
        }

        /* Menu Screen */
        #menu-screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 100%;
            padding: 24px 20px;
            box-sizing: border-box;
            min-height: 60vh;
        }

        .menu-title {
            color: #333;
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 32px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .menu-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            max-width: 800px;
            width: 100%;
        }

        .menu-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: transform 0.2s;
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            border: 1px solid #eee;
            text-align: center;
        }

        .menu-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px rgba(0,0,0,0.1);
            border-color: var(--color-accent);
        }

        .menu-item-label {
            color: #333;
            font-size: 1.25rem;
            font-weight: 600;
        }

        .menu-item-sublabel {
            color: #666;
            font-size: 0.95rem;
        }

        @media (max-width: 700px) {
            .menu-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Game Container */
        .game-section {
            padding: 40px 24px 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #FAFAFA;
            border-top: 1px solid #eee;
            min-height: 100vh;
        }

        .game-container {
            max-width: 1080px;
            width: 100%;
            margin: 0 auto;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .status-text {
            font-weight: 600;
            color: var(--color-accent);
            height: 24px;
        }

        /* Controls */
        .controls-bar {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .btn-control {
            padding: 10px;
            border: 1px solid #e5e7eb;
            background: #fff;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-control:hover {
            background: #f3f4f6;
            border-color: #d1d5db;
        }

        .btn-primary-control {
            background: var(--color-accent);
            color: white;
            border-color: var(--color-accent);
            grid-column: span 2;
        }

        .btn-primary-control:hover {
            filter: brightness(1.1);
            background: var(--color-accent);
        }

        /* Grid */
        .futoshiki-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            padding: 8px;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
            position: relative;
            max-width: 600px; /* Increased size as requested */
            margin: 0 auto;
        }

        .cell {
            aspect-ratio: 1;
            background: #fff;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem; /* Increased font size for larger cells */
            font-weight: 700;
            color: var(--color-text);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            user-select: none;
        }

        .cell:hover {
            border-color: #bfdbfe;
        }

        .cell.selected {
            border-color: var(--color-accent);
            background-color: #eff6ff;
        }

        .cell.initial {
            color: #000;
            background-color: #f3f4f6;
        }
        
        .cell.error {
            color: #ef4444;
            background-color: #fef2f2;
            border-color: #ef4444;
        }

        .cell.success {
            color: #10b981;
            border-color: #10b981;
        }

        /* Inequalities */
        .inequality {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--symbol-color);
            font-weight: bold;
            font-size: 1.2rem;
            z-index: 10;
            pointer-events: none;
        }

        /* Keypad */
        .keypad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
        }

        .key {
            height: 56px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            background: #fff;
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--color-text);
            cursor: pointer;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .key:active {
            transform: translateY(2px);
        }

        .key-action {
            font-size: 1rem;
            background: #f9fafb;
            color: #4b5563;
        }
        
        .key-primary {
            background: var(--color-accent);
            color: white;
            border-color: var(--color-accent);
        }
        
        .key-primary:hover {
            filter: brightness(1.1);
        }

        @media (max-width: 640px) {
            .game-section { padding: 40px 16px; }
        }
        
        @media (max-width: 768px) {
            /* Reduce spacing between puzzle and controls (bottom nav) */
            .game-wrap { gap: 12px !important; }
            .game-main { padding-bottom: 8px !important; }
        }
    </style>
</head>
<body>

    <header>
        <div id="site-header"></div>
    </header>

    <main class="main-wrap">
        <!-- Breadcrumb -->
        <div class="breadcrumb" style="max-width: 1080px; margin: 0 auto; padding: 20px 24px 0; color: #666; font-size: 0.9rem;">
            <a href="/" style="color: #666; text-decoration: none;">Home</a> <span style="margin: 0 8px;">/</span> 
            <span id="breadcrumb-current" style="color: #333; font-weight: 500;">Futoshiki</span>
        </div>

        <!-- Menu Section (Difficulty Selection) -->
        <section id="menu-screen">
            <h1 class="menu-title">Select Difficulty</h1>
            <div class="menu-grid">
                <div class="menu-item" onclick="startGame(4, 'Easy')">
                    <div class="menu-item-label">4x4 Easy</div>
                    <div class="menu-item-sublabel">Perfect for beginners</div>
                </div>
                <div class="menu-item" onclick="startGame(4, 'Hard')">
                    <div class="menu-item-label">4x4 Hard</div>
                    <div class="menu-item-sublabel">Fewer clues</div>
                </div>
                <div class="menu-item" onclick="startGame(5, 'Easy')">
                    <div class="menu-item-label">5x5 Easy</div>
                    <div class="menu-item-sublabel">Standard challenge</div>
                </div>
                <div class="menu-item" onclick="startGame(5, 'Hard')">
                    <div class="menu-item-label">5x5 Hard</div>
                    <div class="menu-item-sublabel">For experienced players</div>
                </div>
                <div class="menu-item" onclick="startGame(6, 'Easy')">
                    <div class="menu-item-label">6x6 Easy</div>
                    <div class="menu-item-sublabel">Big grid, more fun</div>
                </div>
                <div class="menu-item" onclick="startGame(6, 'Hard')">
                    <div class="menu-item-label">6x6 Hard</div>
                    <div class="menu-item-sublabel">Ultimate challenge</div>
                </div>
            </div>
        </section>

        <!-- Game Section -->
        <section id="game" class="game-section" style="display: none;">
            <div class="game-container">
                <div class="game-header">
                    <div>
                        <button onclick="showMenu()" style="border:none; background:none; color:var(--color-accent); cursor:pointer; font-weight:500; margin-right:12px;">‚Üê Menu</button>
                        <h3 id="game-title" style="margin:0; font-size:1.5rem; display:inline-block;">Futoshiki</h3>
                    </div>
                    <div id="status" class="status-text"></div>
                </div>

                <div class="game-wrap">
                    <div class="game-main">
                        <div id="board" class="futoshiki-board">
                            <!-- Cells and constraints generated by JS -->
                        </div>
                    </div>

                    <aside class="game-side">
                        <div class="controls-bar">
                            <button class="btn-control" onclick="clearGame()">Clear</button>
                            <button class="btn-control" onclick="undo()">Undo</button>
                            <button class="btn-control" onclick="showAnswer()">Show Answer</button>
                            <button class="btn-control" onclick="replayGame()">Replay</button>
                            <button class="btn-control btn-primary-control" onclick="newGame()">New Game</button>
                        </div>

                        <div id="keypad" class="keypad">
                            <!-- Generated by JS based on grid size -->
                        </div>
                    </aside>
                </div>
            </div>
        </section>
    </main>

    <div id="site-footer"></div>

    <script>
        // --- 1. Header/Footer Injection ---
        (function(){
            Promise.all([
                fetch('../partials/header.html').then(r => r.text()),
                fetch('../partials/footer.html').then(r => r.text())
            ]).then(([h, f]) => {
                const sh = document.getElementById('site-header');
                const sf = document.getElementById('site-footer');
                if (sh) sh.innerHTML = h;
                if (sf) sf.innerHTML = f;
            }).catch(e => console.error("Partials load error:", e));
        })();

        // --- 2. Game Data & Logic ---
        
        // Base Latin Squares for different sizes (templates)
        const BASE_SOLUTIONS = {
            4: [
                4, 1, 2, 3,
                3, 2, 4, 1,
                1, 4, 3, 2,
                2, 3, 1, 4
            ],
            5: [
                1, 2, 3, 4, 5,
                2, 3, 4, 5, 1,
                3, 4, 5, 1, 2,
                4, 5, 1, 2, 3,
                5, 1, 2, 3, 4
            ],
            6: [
                1, 2, 3, 4, 5, 6,
                2, 3, 4, 5, 6, 1,
                3, 4, 5, 6, 1, 2,
                4, 5, 6, 1, 2, 3,
                5, 6, 1, 2, 3, 4,
                6, 1, 2, 3, 4, 5
            ]
        };

        let currentSettings = {
            size: 4,
            difficulty: 'Easy' // 'Easy', 'Hard'
        };

        let currentLevel = {
            solution: [],
            initial: [],
            constraints: []
        };

        let gridState = [];
        let undoStack = [];
        let selectedCellIndex = null;

        const boardEl = document.getElementById('board');
        const statusEl = document.getElementById('status');
        const keypadEl = document.getElementById('keypad');
        const gameTitleEl = document.getElementById('game-title');
        const menuScreen = document.getElementById('menu-screen');
        const gameSection = document.getElementById('game');

        // --- Core Functions ---

        function startGame(size, difficulty) {
            currentSettings.size = size;
            currentSettings.difficulty = difficulty;
            
            // Update UI
            menuScreen.style.display = 'none';
            gameSection.style.display = 'flex';
            gameTitleEl.textContent = `Futoshiki ${size}x${size} (${difficulty})`;
            
            // Update Grid Style
            boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            boardEl.style.maxWidth = `${size * 70 + 80}px`; // Approximate dynamic width

            initGame();
        }

        function showMenu() {
            if (confirm("Return to menu? Current game progress will be lost.")) {
                gameSection.style.display = 'none';
                menuScreen.style.display = 'flex';
            }
        }

        function initGame() {
            generateNewPuzzle();
            renderBoard();
            renderKeypad();
            setupKeyboard();
        }

        function generateNewPuzzle() {
            const N = currentSettings.size;
            
            // 1. Generate Latin Square (Randomized)
            // Start with a valid cyclic base
            let base = [];
            for(let r=0; r<N; r++) {
                for(let c=0; c<N; c++) {
                    base.push(((r + c) % N) + 1);
                }
            }
            
            // Shuffle Rows (preserve logic)
            // Note: Just shuffling rows of a cyclic Latin square preserves the "Latin Property" (each num once per row)
            // BUT it might break columns.
            // Cyclic square: Row i is (1..N) shifted.
            // If we just shuffle rows, we might get duplicate columns?
            // Wait. A cyclic latin square has columns also distinct.
            // If we permute rows, columns are just reordered elements of original columns.
            // Yes, permuting rows of a Latin Square keeps it a Latin Square.
            // Permuting columns also keeps it a Latin Square.
            // Permuting symbols also keeps it a Latin Square.
            
            const rowMap = Array.from({length: N}, (_, i) => i).sort(() => Math.random() - 0.5);
            const colMap = Array.from({length: N}, (_, i) => i).sort(() => Math.random() - 0.5);
            const valMap = Array.from({length: N}, (_, i) => i + 1).sort(() => Math.random() - 0.5); // 1..N shuffled

            const newSolution = new Array(N*N);
            
            for(let r=0; r<N; r++) {
                for(let c=0; c<N; c++) {
                    // Original position in base
                    const originalVal = base[r*N + c];
                    
                    // New position
                    const newR = rowMap[r];
                    const newC = colMap[c];
                    const newIdx = newR * N + newC;
                    
                    // New value
                    const newVal = valMap[originalVal-1];
                    newSolution[newIdx] = newVal;
                }
            }
            
            // 2. Generate Constraints (Inequalities)
            const newConstraints = [];
            // Randomly add horizontal constraints
            // Difficulty affects density?
            // Easy: Many initial numbers, few constraints? Or Many constraints to guide?
            // Actually, Futoshiki relies on constraints.
            // Let's add random constraints.
            const constraintDensity = 0.4; // Chance of constraint between neighbors
            
            for(let r=0; r<N; r++) {
                for(let c=0; c<N-1; c++) { // Horizontal neighbors
                     if(Math.random() < constraintDensity) {
                         const idx1 = r*N + c;
                         const idx2 = r*N + (c+1);
                         const v1 = newSolution[idx1];
                         const v2 = newSolution[idx2];
                         newConstraints.push({ idx1, idx2, type: v1 > v2 ? '>' : '<' });
                     }
                }
            }
            
            // Vertical constraints (optional for now, but good for higher diff)
            // Let's stick to horizontal for simplicity of rendering unless I update renderConstraint
            // Update renderConstraint to handle vertical?
            // Let's add vertical support to renderConstraint first.
            
            // 3. Generate Initial Numbers (Clues)
            // Easy: Show 50% numbers. Hard: Show 20% numbers.
            const clueRate = currentSettings.difficulty === 'Easy' ? 0.4 : 0.2;
            const newInitial = new Array(N*N).fill(0);
            
            for(let i=0; i<N*N; i++) {
                if(Math.random() < clueRate) {
                    newInitial[i] = newSolution[i];
                }
            }

            currentLevel.solution = newSolution;
            currentLevel.initial = newInitial;
            currentLevel.constraints = newConstraints;
            
            gridState = [...newInitial];
            undoStack = [];
            selectedCellIndex = null;
            statusEl.textContent = '';
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            const N = currentSettings.size;
            
            // Render Cells
            gridState.forEach((val, index) => {
                const cell = document.createElement('div');
                cell.className = `cell ${currentLevel.initial[index] !== 0 ? 'initial' : ''}`;
                if (index === selectedCellIndex) cell.classList.add('selected');
                
                // Adjust font size for larger grids
                if (N >= 6) cell.style.fontSize = '1.8rem';
                
                cell.textContent = val === 0 ? '' : val;
                cell.onclick = () => selectCell(index);
                boardEl.appendChild(cell);
            });

            // Render Constraints
            currentLevel.constraints.forEach(c => {
                renderConstraint(c);
            });
        }

        function renderConstraint(c) {
            const cell1 = boardEl.children[c.idx1];
            if (!cell1) return;
            
            // Check direction
            const N = currentSettings.size;
            const diff = c.idx2 - c.idx1;
            
            const marker = document.createElement('span');
            marker.className = 'inequality';
            marker.textContent = c.type;
            marker.style.position = 'absolute';
            marker.style.pointerEvents = 'none';
            marker.style.color = '#6b7280';
            marker.style.fontWeight = 'bold';

            if (diff === 1) { // Horizontal (Right)
                marker.style.right = '-14px';
                marker.style.top = '50%';
                marker.style.transform = 'translateY(-50%)';
                cell1.appendChild(marker);
            } else if (diff === N) { // Vertical (Bottom) -- Not generated yet but logic ready
                 marker.style.bottom = '-14px';
                 marker.style.left = '50%';
                 marker.style.transform = 'translateX(-50%) rotate(90deg)';
                 cell1.appendChild(marker);
            }
        }
        
        function renderKeypad() {
            keypadEl.innerHTML = '';
            const N = currentSettings.size;
            
            // Dynamic Grid for Keypad
            keypadEl.style.gridTemplateColumns = `repeat(${Math.min(N, 4)}, 1fr)`;
            
            for(let i=1; i<=N; i++) {
                const btn = document.createElement('button');
                btn.className = 'key';
                btn.textContent = i;
                btn.onclick = () => inputNumber(i);
                keypadEl.appendChild(btn);
            }
            
            // Add Clear and Check
            const clearBtn = document.createElement('button');
            clearBtn.className = 'key key-action';
            clearBtn.textContent = 'Clear';
            clearBtn.onclick = () => inputNumber(0);
            keypadEl.appendChild(clearBtn);
            
            const checkBtn = document.createElement('button');
            checkBtn.className = 'key key-primary';
            checkBtn.textContent = 'Check';
            checkBtn.onclick = () => checkSolution();
            keypadEl.appendChild(checkBtn);
        }

        function selectCell(index) {
            selectedCellIndex = index;
            statusEl.textContent = '';
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('selected'));
            renderBoard(); // Re-render to show selection
        }

        function inputNumber(num) {
            if (selectedCellIndex === null) return;
            if (currentLevel.initial[selectedCellIndex] !== 0) return;
            
            undoStack.push([...gridState]);
            gridState[selectedCellIndex] = num;
            renderBoard();
            statusEl.textContent = '';
        }

        // --- Controls ---

        function undo() {
            if (undoStack.length === 0) return;
            gridState = undoStack.pop();
            renderBoard();
            statusEl.textContent = '';
        }

        function clearGame() {
            if (confirm('Clear the board?')) {
                undoStack.push([...gridState]);
                gridState = [...currentLevel.initial];
                renderBoard();
                statusEl.textContent = '';
            }
        }

        function replayGame() {
             if (confirm('Restart this game?')) {
                gridState = [...currentLevel.initial];
                undoStack = [];
                renderBoard();
                statusEl.textContent = '';
             }
        }

        function newGame() {
            if (confirm('Start a new game with same settings?')) {
                initGame();
            }
        }

        function showAnswer() {
            if (confirm('Show solution?')) {
                undoStack.push([...gridState]);
                gridState = [...currentLevel.solution];
                renderBoard();
                statusEl.textContent = 'Solution shown.';
            }
        }

        function checkSolution() {
            const N = currentSettings.size;
            const totalCells = N*N;
            
            let isValid = true;
            if (gridState.includes(0)) {
                statusEl.textContent = 'Incomplete!';
                statusEl.style.color = '#ef4444';
                return;
            }

            // Check against solution
            for(let i=0; i<totalCells; i++) {
                if (gridState[i] !== currentLevel.solution[i]) {
                    isValid = false;
                    break;
                }
            }

            if (isValid) {
                statusEl.textContent = 'Success! Well done.';
                statusEl.style.color = '#10b981';
                document.querySelectorAll('.cell').forEach(c => c.classList.add('success'));
            } else {
                statusEl.textContent = 'Incorrect. Keep trying.';
                statusEl.style.color = '#ef4444';
                document.querySelectorAll('.cell').forEach((c, i) => {
                     if (currentLevel.initial[i] === 0 && gridState[i] !== currentLevel.solution[i]) {
                         c.classList.add('error');
                     }
                });
            }
        }

        function setupKeyboard() {
            // Remove old listeners? No easy way unless we store controller.
            // But this function is called only once per page load ideally, or we ensure it's idempotent.
            // Actually, initGame calls it. It adds multiple listeners!
            // Fix: Move to global scope or check flag.
        }
        
        let keyboardInitialized = false;
        function setupKeyboard() {
            if(keyboardInitialized) return;
            keyboardInitialized = true;
            
            document.addEventListener('keydown', (e) => {
                if (selectedCellIndex === null) return;
                const N = currentSettings.size;
                
                // Numbers
                if (parseInt(e.key) > 0 && parseInt(e.key) <= N) {
                    inputNumber(parseInt(e.key));
                }
                // Backspace/Delete -> 0
                else if (e.key === 'Backspace' || e.key === 'Delete') {
                    inputNumber(0);
                }
                // Arrows
                else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    moveSelection(e.key);
                }
            });
        }

        function moveSelection(key) {
            const N = currentSettings.size;
            let r = Math.floor(selectedCellIndex / N);
            let c = selectedCellIndex % N;
            
            if (key === 'ArrowUp') r = (r - 1 + N) % N;
            if (key === 'ArrowDown') r = (r + 1) % N;
            if (key === 'ArrowLeft') c = (c - 1 + N) % N;
            if (key === 'ArrowRight') c = (c + 1) % N;
            
            const newIdx = r * N + c;
            selectCell(newIdx);
        }
        
        // Initial State: Show Menu (Don't call initGame immediately)
        // initGame();

    </script>
    <script src="/src/records.js"></script>
</body>
</html>